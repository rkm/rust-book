# Other misc. notes

## [Rust Programming Techniques](https://www.youtube.com/watch?v=vqavdUGKeb4)

-   [50:20] Difference between `vec.iter().for_each(...)` and `for v in &vec ...`. Although `Vec` implements IntoIterator, in the first case (`impl<T> IntoIterator for Vec<T>`) it gives you an iterator over all the values, and in the second case (`impl<'a, T> IntoIterator for &'a Vec<T>`) it gives you an iterator over references to all the values. Which one you want depends on whether you want to "consume" the input vector or not.
-   [52:40] The `Iterator` trait has one method named `next()` which, when called, advances the iterator and returns an `Option` containing `Some(Item)`, or `None` when there are no more items.
-   [53:45] The for loop is essentially the same as a `while let Some(x)` over an iterator. You can use either form depending on how much control you want over the iterator. Also have the infinite `while { ... }` loop available.
-   [58:00] What to do when you get an `Err` result? Recover (with default value etc.), give it to the user (usually wrong, shouldn't show internal error types to the user), re-throw (i.e. with `?` operator), or panic! Panicking crashes the current thread in a controlled manner by unwinding the stack and calling destructors etc. Can be caught at thread boundaries. Can explicitly call `panic!("msg");`, or rely on `x.unwrap()` / `x.expect()` etc. Try and model errors around module boundaries, think of what is actually relevant to users etc. Suggestion is that you should re-throw errors inside a given module, and have one place in the external API where these are caught and converted into more useful messages.
-   [1:07:10] Aliasing types is good practice and helps readability i.e. `type MyResult<T> = Result<T, MyErr>;`
-   [1:14:30] Recommendataion for initial error handling is to use strings rather than calling panic everywhere.
-   [1:18:30] Rust is a very object-oriented language, but definitely not a class-oriented language. Traits just share behaviour, whereas classes also share data. Traits are mostly unstructured, whereas classes are hierarchical. Trait implementations can be added post-hoc, whereas class inheritance must be declared ahead of time (i.e. can implement your own traits for i32). Some traits are "empty" i.e. Send & Sync which just tell the compiler that a type is safe to be moved/shared between threads. Can only create an impl if you are in the same crate as either the data type or trait definitions (or both).
-   [1:25:10] Can write "inherent" impl, which doesn't name a trait at all which can just be used to add methods to a type. Similar to classic OOP, but should really try and use traits instead to help testing & design etc. (with sensible limits as usual).
-   [1:27:20] What makes a good trait? Small (few methods), independent (reduce coupling).
-   [1:28:05] What makes a good data structure? Behaviour specific to the data, constructors, getters, setters etc. Things that would be interfaces in other languages should be traits in Rust.
-   [1:29:40] Some useful standard traits - Default to return an instance of an object in some initial state, Display for user-facing string repr., Debug for developer-facing string repr.
